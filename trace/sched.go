package main

func main() {

	/*   每个线程都有一个g0, 线程本地存储中存放当前绑定的g,M的结构体，处理器p，g0等信息
		//
		//      g0是一个特殊协程，执行协程调度时的逻辑，每次调度都会切换到g0执行
		//        1. 处理具体调度策略
		//        2. 执行状态的切换，以及g与m的绑定关系
		//        3. 保存当前协程的上下文信息
		//    调度时，找当前绑定的p的运行队列，
		          如果为空，则从全局队列中获取。
				  如果全局队列为空，则从其他p中获取。为防止全局队列饿死，每61次调度后，优先从全局队列中取一批到本地队列
				  如果全局队列也为空，则从其他p偷取一部分到本地队列
				  如果其他p也为空，则接触当前p与m的绑定关系，m进入休眠状态, p放入空闲的p队列

				  如果本地队列满了， 调度器会将本地运行队列中的一半放入全局队列中


			  网络请求处理就绪时，找到等待中协程，将其放入全局运行队列，等待被调度


			  调度时机：
			   1. 主动调度，g调用runtime.Gosched()主动让出CPU
			      (1.14之前无限循环无法被抢占，1.14之后，通过信号量机制，可以抢占)
				   调度器向操作系统发送sigurg信号，操作系统触发中断处理程序，状态进行处理后，回到用户态处理逻辑，打断循环执行

				 主动调度，从当前协程切换到g0,接触G与M的绑定关系，将当前协程放入全局运行队列，重新调度
			   2. 被动调度
	             场景： 休眠，channel阻塞，网络io阻塞，垃圾回收暂停时，被动让渡自己的执行权利
				 被动调度由协程发起，从当前协程切换到g0,接触G与M的绑定关系，重新调度,(不会放入全局运行队列)

				 通道中没消息时，会执行gopark完成被动调度，gopark中会调用schedule()函数，完成调度

				 gopark 会将协程状态变为waiting状态, 等到需要唤醒时，变为runnable，并添加到当前p运行队列

			   3. 抢占调度

			     为了最大化利用cpu资源，启动特殊的线程监控系统
				    监控什么？ 所有p
					  1. 每个10ms检测是否有准备就绪的网络协程, 如果有就放入全局队列
					  2. 是否有G执行时间过长，如果有，则抢占
					  3. 是否处于系统调用阶段，如果有，则抢占

			系统调用时的抢占，将P的状态转换pidle,此时，需要新的M接管这个P

			  什么时候会启动一个M来接管P?
			  1. 队列中有等待运行的G
			  2. 需要处理一些垃圾回收的任务
			  3. 没有自旋的M
			  4. 全局队列不空
			  5. 需要处理socket读写等事件

			  不满足上述条件时，p放入空闲队列

			当从线程从系统调用返回后，看能否绑定P，
			如果不能，这解除当前P与自己的关系，找个能够绑定的
			如果找不到，这将G放入全局运行队列，当前线程进入休眠状态

	*/

}
