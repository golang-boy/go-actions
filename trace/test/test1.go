package main

import "fmt"

func main() {

	a := "O(∩_∩)O哈哈~"

	for i := 0; i < len(a); i++ {
		fmt.Printf("%U %#U\n", a[i], a[i])
	}

	fmt.Println("=======================================")

	for _, v := range a {
		fmt.Printf(" %#U %+U\n", v, v)
	}

	bar()

	slice()
}

func foo() {
	// 字符串拼接
	//  拼接后的字符串，如果长度小于32字节，使用临时buf存放
	//  如果大于32字节，则申请一个足够大的空间，把字符串copy进去

	// 字符串与字节数组互相转换
	//  字符串转字节数组，小于32字节，使用临时buf存放,大于时，申请空间进行copy

	// rune 四个字节 int32整数

}

func bar() {
	// 数组声明方式
	var arr [3]int
	var arr2 = [3]int{1, 2, 3}
	arr3 := [...]int{1, 2, 3}

	fmt.Printf("%T\n", arr)
	fmt.Printf("%T\n", arr2)
	fmt.Printf("%T\n", arr3)

	// 函数调用和数组赋值, 都是值复制
	//
	a := [3]int{1, 2, 3}
	b := a
	b[0] = 100
	fmt.Println(a, b)
}

func slice() {
	// 切片声明方式
	var s []int
	var s2 = []int{1, 2, 3}
	var s3 = make([]int, 3, 5) // 不指定容量时，与长度相同

	fmt.Printf("%T\n", s)
	fmt.Printf("%T\n", s2)
	fmt.Printf("%T\n", s3)

	// 切片复制
	//   data, len, cap   8字节+
	//   头部复制，数据是引用同一块内存

	// 原理
	//   编译时，确定切片元素的类型
	//   make初始化时，如果初始化一个小的，则在栈上，否则会逃逸到堆上, 64kb, make([]int64, 1023)与make([]int64, 1024)差别很大

	// 切片扩容与缩容
	//   扩容时，如果小于1024，则翻倍，大于1024，则增加1/4
	//   缩容时，如果小于1024，则减少1/4，大于1024，则减少1/2
	//   扩容时，如果超过最大容量，则申请一个新的数组，把数据copy进去

	// 切片截取
	old := make([]int, 3, 5)
	new := old[1:3]

	fmt.Printf("%p, %p\n", old, new)
}

func hashmap() {
	// 哈希表
	//    拉链法，数组+链表
	//    开放寻址法，数组+数组:   **线性探测**(go map的实现方式)，二次探测，双重哈希

	// a := make(map[string]int)

	// 对应底层结构为hmap, buckets对应桶起始指针，指向bmap, bmap为桶，存储键值对，内存上，key，value存储时连续的
	//  tophash存储key的高八位
	//  查找时，先根据key哈希的第八位找到桶序号，在根据高八位找到key位置
	//    如果key 不在当前桶，那就继续遍历当前桶的溢出桶。

	// 当前桶的溢出桶，以链表的形式进行扩展

	// 但是这样有个问题: 如果桶中有溢出桶，overflow 应该指向对应的溢出桶地址，但是由于 uintptr 类型不被认为是引用，这部分内存可能就会被 GC 回收掉。
	//  为了避免这个问题，需要有个地方能够直接引用这些溢出桶，也就是hmap 的extra字段，该字段为*mapextra类型。

	// 负载因子6.5与溢出桶过多，会触发扩容

	//   增量扩容
	//      负载因子的计算和桶的数量(即 B)有关，因此如果负载因子过大，则说明B过小，此时需要将 B 加 1，对应的桶数变成了原来的 2 倍，这就是增量扩容；
	//   等量扩容
	// 可能是溢出桶太多了，实际数据并没有那么多，这样会影响查找效率。比如连续插入数据后删除，导致溢出桶很多。这种情况下只需要将松散的数据集中起来即可，桶数量保持不变，这就是等量扩容。

}

func function() {

}
